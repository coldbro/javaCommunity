创建线程的三种方式及区别
第一种方式，继承Thread类
第二种方式，实现Runnable接口，避免单继承问题，Java只能单继承但是可以多实现
第三种方式，匿名内部类
----------
同步的弊端
1 效率低
2 如果出现同步嵌套，会出现死锁问题
死锁问题：是指两个或两个以上的的线程在执行的过程中，因争夺资源而产生的一种互相等待的现象
----------
线程间通信
针对同一个资源的操作有不同的种类的线程
通过设置线程（生产者）和获取线程（消费者）争对图书对象进行操作（TestBook)
生产者
    先看是否有数据，有就等待，没有就生成，生成完之后通知消费者来消费
消费者
    先看是否有数据，有就消费，没有就等待，通知生产者生产数据
Java提供一种机制：等待唤醒机制
----------
java使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理
java允许程序直接对线程组进行控制
默认情况下所有的线程都属于主线程组
pulic final ThreadGroup getThreadGroup()
也可以给线程设置分组
Thread(ThreadGroup group,Runnable target,String name )
----------
线程池（增加了一个Executors工厂类来产生线程池）
程序起到一个新线程成本是比较高的，因为涉及到与操作系统的进行交互。
而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时
更应该考虑使用线程池
线程池里的每一个线程代码结束后不会死亡（用完之后回收到线程池中）
而是再次回到线程池成为空闲状态，等待下一个对象来使用
----------
线程生命周期
新建-->就绪-|->运行-->死亡
           |
           阻塞
----------
为什么wait，notify,notifyall在Object类中
这些方法存在同步中，使用这些方法是必须要表示所属的同步的锁
